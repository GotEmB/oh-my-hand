// Generated by CoffeeScript 1.5.0
var __slice = [].slice;

require.config({
  paths: {
    knockout: "//ajax.aspnetcdn.com/ajax/knockout/knockout-2.2.1",
    bootstrap: "lib/bootstrap",
    jquery: "//code.jquery.com/jquery-1.9.1.min",
    underscore: "//cdnjs.cloudflare.com/ajax/libs/underscore.js/1.4.4/underscore-min"
  },
  shim: {
    underscore: {
      exports: "_"
    },
    bootstrap: {
      deps: ["jquery"]
    }
  }
});

require(["knockout", "jquery"], function(ko, $) {
  var app;
  window.app = app = {
    container: ko.observable("startScreen"),
    balance: {
      value: ko.observable("1000")
    },
    bigBlind: {
      value: ko.observable("20")
    },
    smallBlind: {
      value: ko.observable("10")
    },
    players: ko.observableArray([]),
    selectedPlayer: ko.observable(null),
    currentPlayer: ko.observable(null),
    addPlayerInput: ko.observable(""),
    playerDND: {
      mousedown: function(context, e) {
        if (app.playerDND.state != null) {
          return true;
        }
        if ((e.changedTouches != null) && e.changedTouches.length !== 1) {
          return true;
        }
        if (typeof e.preventDefault === "function") {
          e.preventDefault();
        }
        app.playerDND.state = {
          context: context,
          startY: e.clientY || e.y || e.changedTouches[0].clientY,
          domNode: e.currentTarget.parentElement,
          shift: 0
        };
        return e.currentTarget.parentElement.style.zIndex = 10;
      },
      mousemove: function(context, e) {
        var bounds, currentPosition, i, idx, movedDistance, node, _i, _j, _len, _ref, _ref1, _ref2, _results;
        if (app.playerDND.state == null) {
          return true;
        }
        if ((e.changedTouches != null) && e.changedTouches.length !== 1) {
          return true;
        }
        if (typeof e.preventDefault === "function") {
          e.preventDefault();
        }
        movedDistance = (e.clientY || e.y || e.changedTouches[0].clientY) - app.playerDND.state.startY;
        currentPosition = (function() {
          var i, pos;
          pos = 0;
          i = 0;
          while (app.playerDND.state.domNode.parentElement.children[i] !== app.playerDND.state.domNode) {
            pos += app.playerDND.state.domNode.parentElement.children[i].clientHeight;
            i++;
          }
          return pos + i - 1;
        })();
        bounds = {
          min: app.playerDND.state.domNode.parentElement.children[0].clientHeight - currentPosition,
          max: app.playerDND.state.domNode.parentElement.clientHeight - app.playerDND.state.domNode.clientHeight - currentPosition - 3
        };
        if (movedDistance < bounds.min) {
          movedDistance = bounds.min;
        }
        if (movedDistance > bounds.max) {
          movedDistance = bounds.max;
        }
        app.playerDND.state.domNode.style.top = movedDistance + "px";
        app.playerDND.state.shift = movedDistance;
        _ref = app.playerDND.state.domNode.parentElement.children;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          node = _ref[_i];
          if (node !== app.playerDND.state.domNode) {
            node.style.top = "0px";
          }
        }
        if (Math.abs(movedDistance) > app.playerDND.state.domNode.clientHeight) {
          idx = $(app.playerDND.state.domNode).index();
          _results = [];
          for (i = _j = _ref1 = movedDistance / Math.abs(movedDistance), _ref2 = movedDistance / app.playerDND.state.domNode.clientHeight; _ref1 <= _ref2 ? _j <= _ref2 : _j >= _ref2; i = _ref1 <= _ref2 ? ++_j : --_j) {
            _results.push(app.playerDND.state.domNode.parentElement.children[idx + i].style.top = (-(movedDistance / Math.abs(movedDistance)) * (app.playerDND.state.domNode.clientHeight + 1)) + "px");
          }
          return _results;
        }
      },
      mouseup: function(context, e) {
        var idx, node, shx, _i, _len, _ref, _ref1;
        if (app.playerDND.state == null) {
          return true;
        }
        if ((e.changedTouches != null) && e.changedTouches.length !== 1) {
          return true;
        }
        if (typeof e.preventDefault === "function") {
          e.preventDefault();
        }
        app.playerDND.state.domNode.style.zIndex = 0;
        _ref = app.playerDND.state.domNode.parentElement.children;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          node = _ref[_i];
          node.style.top = "0px";
        }
        idx = app.players.indexOf(app.playerDND.state.context);
        shx = parseInt(app.playerDND.state.shift / app.playerDND.state.domNode.clientHeight);
        (_ref1 = app.players).splice.apply(_ref1, [idx + shx, 0].concat(__slice.call(app.players.splice(idx, 1))));
        return delete app.playerDND.state;
      }
    },
    setupNewGame: function() {
      window.history.pushState({
        container: "setupNewGame"
      }, "Oh My Hand!", "");
      return app.container("setupNewGame");
    },
    addPlayer: function(context, event) {
      var thisPlayer;
      if (!((event.which || event.keyCode) === 13 && app.addPlayerInput() !== "")) {
        return true;
      }
      app.players.push(thisPlayer = {
        token: "Blackjack",
        name: ko.observable(app.addPlayerInput()),
        balance: ko.observable(app.balance.value()),
        admin: ko.observable(app.players().length === 0),
        selectPlayer: function() {
          return app.selectedPlayer(thisPlayer);
        },
        toggleAdmin: function() {
          return thisPlayer.admin(!thisPlayer.admin());
        },
        removePlayer: function() {
          return app.players.remove(thisPlayer);
        }
      });
      if (app.currentPlayer() == null) {
        app.currentPlayer(thisPlayer);
      }
      return app.addPlayerInput("");
    }
  };
  window.onpopstate = function(event) {
    console.log(event.state);
    if (event.state == null) {
      return app.container("startScreen");
    }
    return app.container(event.state.container);
  };
  return $(function() {
    return ko.applyBindings(app);
  });
});
